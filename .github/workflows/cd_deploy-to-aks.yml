# This workflow is responsible for deploying the application to an Azure Kubernetes Service (AKS) cluster.
# It is triggered automatically when the CI workflow completes (for both PR and main branch deployments),
#   or it can be triggered manually via workflow_dispatch.
name: CD - Deploy to AKS
permissions: { } # default to minimal permission, overriding in jobs only as needed
on:
  # Trigger deployment after successful CI run (for both merged commits and PR builds)
  workflow_run:
    workflows: [ CI ]
    types:
      - completed
  # Allow manual trigger of workflow to deploy to specified environment
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        required: true
        description: "Deployment environment"
        options:
          - "Staging"
          - "Development"
          - "Production"
      acme_provider_name:
        type: choice
        required: true
        description: "ACME provider"
        default: "Let's Encrypt - Staging"
        options:
          - "Let's Encrypt - Production"  # Ideal when deploying to publicly accessible domain
          - "Let's Encrypt - Staging"     # Ideal when frequently testing deployment (avoid rate limits on prod server)
jobs:
  # If triggered by a workflow_run, ensure the CI was successful. If not, skip deployment
  check-context:
    runs-on: ubuntu-latest
    steps:
      - name: Get the workflow's triggering context
        run: |
          if [[ "${{ github.event.workflow_run.event_name }}" == "workflow_dispatch" ]]; then
            echo "Workflow triggered manually"
          elif [[ "${{ github.event.workflow_run.event_name }}" == "pull_request" ]]; then
            echo "This workflow was triggered by the CI workflow's completion. CI was triggered by a pull request."
            # could use 'break' here and combine with the next step(s), but this is more explicit
          else
            echo "Error: Unsupported event '${{ github.event.workflow_run.event_name }}'."; exit 1
          fi

      - name: Get context on pull request
        if: ${{ github.event.workflow_run.event_name == 'pull_request' }}
        id: get-pr-context
        run: |
          if [[ "${{ github.event.workflow_run.event.pull_request.base.ref }}" == "main" ]]; then
            echo "PR is to main branch."
          fi
          # given this workflow is triggered by the CI workflow, we enforce that the CI was successful before proceeding
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
              echo "CI was successful."
          else
              echo "CI failed; skipping deployment (workflow will quit here)."; exit 1
          fi
          # extra info for debugging
          echo "PR base ref: ${{ github.event.workflow_run.event.pull_request.base.ref }}"
          echo "PR head ref: ${{ github.event.workflow_run.event.pull_request.head.ref }}"
          echo "PR number: ${{ github.event.workflow_run.event.pull_request.number }}"
          echo "PR title: ${{ github.event.workflow_run.event.pull_request.title }}"

  prepare-deployment:
    runs-on: ubuntu-latest
    env:
      ROOT_DOMAIN: "litter.dev"
    outputs:
      image_path: ${{ steps.image-path.outputs.image_path }}
      image_tag: ${{ steps.determine-image-tag.outputs.image_tag }}
      environment_name: ${{ steps.determine-env.outputs.environment_name }}
      environment_code: ${{ steps.determine-env.outputs.environment_code }}
      environment_url: ${{ steps.determine-env.outputs.environment_url }}
      acme_provider_url: ${{ steps.determine-acme-url.outputs.acme_provider_url }}
      app_helm_overrides_path: ${{ steps.select-helm-overrides.outputs.app_helm_overrides_path }}
    steps:
      # Image repo must be lowercase and GitHub Actions doesn't have easy string manipulation.
      #   Was causing issues when username had an uppercase letter
      #   See: https://github.com/orgs/community/discussions/10553
      - name: Set image path (to lowercase)
        id: image-path
        run: |
          imagePath="ghcr.io/${GITHUB_REPOSITORY,,}"
          echo "image_path=$imagePath" >> $GITHUB_OUTPUT
          echo "Image path: $imagePath"

      # Determine the deployment environment details (name, code, URL) based on the triggering context:
      # - For manual dispatch, use the given input for environment name and pre-defined environment codes
      # - For workflow_run:
      #   - If the CI workflow was triggered by a pull request event, deploy to an ephemeral environment
      #     named "PR Staging: #<pr number>" with environment code "pr-<pr number>-staging"
      # - For push event (always to main branch):
      #   - Deploy to production environment, with environment code "prod"
      - name: Determine Environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            environmentName="${{ github.event.inputs.environment }}"
            case "$environmentName" in
              "Production")
                environmentCode="prod"
                ;;
              "Staging")
                environmentCode="staging"
                ;;
              "Development")
                environmentCode="dev"
                ;;
            esac
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            CI_TRIGGER_EVENT="${{ github.event.workflow_run.event_name }}"
            if [[ "$CI_TRIGGER_EVENT" == "pull_request" ]]; then
              pr_number="${{ github.event.workflow_run.event.pull_request.number }}"
              environmentName="PR Staging: #$pr_number"
              environmentCode="pr-${pr_number}-staging"
            else
              environmentName="Production"
              environmentCode="prod"
            fi
          else
            echo "Error: Unsupported event '${{ github.event_name }}'."; exit 1
          fi
          environmentURL="https://${{ steps.determine-env.outputs.environment_code }}.${{ env.ROOT_DOMAIN }}"

          echo "environment_name=$environmentName"  >> $GITHUB_OUTPUT
          echo "environment_code=$environmentCode"  >> $GITHUB_OUTPUT
          echo "environment_url=$environmentURL"    >> $GITHUB_OUTPUT
          echo "Environment: '$environmentName' (code: '$environmentCode', URL: '$environmentURL')"

      # Determine the correct ACME Server URL based on the triggering context:
      # - For workflow_dispatch:
      #   - If the provided ACME provider name is "Let's Encrypt - Production", use the production endpoint.
      #   - If the provided ACME provider name is "Let's Encrypt - Staging", use the staging endpoint.
      # - For workflow_run:
      #   - If the determined environment code is "prod", use the production endpoint;
      #     otherwise, use the staging endpoint.
      - name: Determine ACME Server URL
        id: determine-acme-url
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.acme_provider_name }}" == "Let's Encrypt - Production" ]]; then
              acmeProviderURL="https://acme-v02.api.letsencrypt.org/directory"
            elif [[ "${{ github.event.inputs.acme_provider_name }}" == "Let's Encrypt - Staging" ]]; then
              acmeProviderURL="https://acme-staging-v02.api.letsencrypt.org/directory"
            else
              echo "Error: Unsupported ACME provider '${{ github.event.inputs.acme_provider_name }}'."; exit 1
            fi
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            if [[ ${{ steps.determine-env.outputs.environment_code }} == "prod" ]]; then
              acmeProviderURL="https://acme-v02.api.letsencrypt.org/directory"
            else
              acmeProviderURL="https://acme-staging-v02.api.letsencrypt.org/directory"
            fi
          else
            echo "Error: Unsupported event '${{ github.event_name }}'."; exit 1
          fi
          echo "acme_provider_url=$acmeProviderURL" >> $GITHUB_OUTPUT
          echo "ACME Provider URL: $acmeProviderURL"

        # Determine the correct Docker image tag based on the triggering context:
        # - For workflow_run:
        #   - If the triggering event is a pull request, tag with "pr-<pr number>"
        #   - Otherwise, for push events (merged to main) tag with the commit SHA
        # - For manual (workflow_dispatch), default to the "latest" tag
      - name: Determine Image Tag
        id: determine-image-tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            CI_TRIGGER_EVENT="${{ github.event.workflow_run.event_name }}"
            if [[ "$CI_TRIGGER_EVENT" == "pull_request" ]]; then
              pr_number="${{ github.event.workflow_run.event.pull_request.number }}"
              imageTag="pr-${pr_number}"
            else
              # For push events (merged to main) use the commit SHA
              imageTag="${{ github.event.workflow_run.head_sha }}"
            fi
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual dispatch, default to "latest"
            imageTag="latest"
          else
            echo "Error: Unsupported event '${{ github.event_name }}'."; exit 1
          fi
          echo "image_tag=$imageTag" >> $GITHUB_OUTPUT
          echo "Determined Image Tag: $imageTag"

      # Select the override file based on the determined environment:
      #  - "prod" -----------> use "./chart/values.prod.yaml"
      #  - "staging" or PR --> use "./chart/values.staging.yaml"
      #  - "dev" or other ---> use "./chart/values.dev.yaml"
      - name: Select Helm Overrides File
        id: select-helm-overrides
        run: |
          ENV_CODE="${{ steps.determine-env.outputs.environment_code }}"
          if [[ "$ENV_CODE" == "prod" ]]; then
            OVERRIDES="./chart/values.prod.yaml"
          elif [[ "$ENV_CODE" == "staging" || "$ENV_CODE" =~ ^pr-.*-staging$ ]]; then
            OVERRIDES="./chart/values.staging.yaml"
          else
            OVERRIDES="./chart/values.dev.yaml"
          fi
          echo "app_helm_overrides_path=$OVERRIDES" >> $GITHUB_OUTPUT
          echo "Selected override file: $OVERRIDES"

  deploy-to-aks:
    needs: prepare-deployment
    runs-on: ubuntu-latest
    env:
      # Azure credentials (cannot use azure/login action with service principal)
      #   See: https://github.com/hashicorp/terraform-provider-azurerm/issues/22034
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      TERRAFORM_WORKING_DIR: "./terraform"
    environment:
      name: ${{ needs.prepare-deployment.outputs.environment_name }}
      url: ${{ needs.prepare-deployment.outputs.environment_url }}
    permissions:
      contents: read
    timeout-minutes: 25 # This can take a WHILE, especially on first deployment & with cheap node SKUs
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd
        with:
          terraform_version: "~> 1.10.0"

      # Set the backend key dynamically
      # Ideally the 'azurerm' backend would support 'workspace_key_prefix = "env"' but it doesn't
      #   See: https://github.com/hashicorp/terraform/issues/28985
      # To get around this and have our deployments isolated, this job does a janky implementation of this
      #   by updating the key in the backend.tf file.
      # Again, this is a workaround and not the best practice, but we have to make due until the backend supports it.
      - name: Update Terraform backend key dynamically
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        env:
          BACKEND_FILENAME: "backend.tf" # within the working directory
          STATE_KEY_PREFIX: "env-" # Prefix for the state key
          WORKSPACE_CODE: ${{ needs.prepare-deployment.outputs.environment_code }}
        run: |
          # Construct the new key by prepending the prefix to the workspace code
          NEW_KEY="${STATE_KEY_PREFIX}${WORKSPACE_CODE}.tfstate"
          echo "Updating Terraform backend key to ${NEW_KEY}"
          # Use extended regular expressions to update the key, regardless of whitespace differences
          sed -E -i "s/^[[:space:]]*key[[:space:]]*=[[:space:]]*\"[^\"]*\"/  key = \"${NEW_KEY}\"/" $BACKEND_FILENAME

      - name: Terraform init
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform init

      - name: Select Terraform workspace
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform workspace select ${{ needs.prepare-deployment.outputs.environment_code }}

      - name: Terraform validate
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform validate

      - name: Terraform plan
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        id: tf-plan
        run: | # For app image tag, use the output from determine-image-tag
          terraform plan \
            -var-file="example.tfvars" \
            -var "az_dns_rg=${{ vars.AZ_DNS_RG }}" \
            -var "az_dns_zone_name=${{ vars.AZ_DNS_ZONE_NAME }}" \
            -var "az_subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var "acme_provider_url=${{ needs.prepare-deployment.outputs.acme_provider_url }}" \
            -var "app_environment=${{ needs.prepare-deployment.outputs.environment_code }}" \
            -var "app_image_repo_url=${{ needs.prepare-deployment.outputs.image_path }}" \
            -var "app_image_tag=${{ needs.prepare-deployment.outputs.image_tag }}" \
            -var "app_helm_overrides_path=${{ needs.prepare-deployment.outputs.app_helm_overrides_path }}" \
            -out=tfplan

      - name: Terraform apply
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform apply -auto-approve tfplan

  report-pr-status:
    needs: [ prepare-deployment, deploy-to-aks ]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      statuses: write
    if: ${{ always() && github.event.workflow_run.event == 'pull_request' }} # Only report status for PRs (run job even if prev jobs fail)
    steps:
      - name: Update PR status
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const conclusion = '${{ needs.deploy-to-aks.result || 'failure' }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: '${{ github.event.workflow_run.head_sha }}',
              state: conclusion,
              context: 'CD - Deploy to AKS',
              description: conclusion === 'success' ? 'Staging deployment successful' : 'Deployment failed',
              target_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
            });
